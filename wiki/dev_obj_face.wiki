#summary Information on the epiClock Face Object
#labels Phase-Design

= epiClock Clock =
The face object contains functions and methods to display to the user on a web page the current time, as calculated by the [dev_obj_clock Clock Object].

== Methods and Properties ==

|| *Properties* || *Type* || *Description* ||
|| dir || String || The relative directory path to any images that will be used by this clock face. ||
|| ext || String || The extension representing the MIME type of any images that will be used. (gif,png,jpg,...) ||
|| pre || Array || Any array containing the prefixes of your images. Expects 3 values which map to the [dev_obj_face_images Image Types]. ||
|| type || String || The [dev_obj_face_type Face Type] which this face object represents. ||
|| sep || String || The character to use to separate hours, minutes, and seconds. (ex. If the sep character is ':', the format output will be hh:mm:ss. If the char is '-', the output will be hh-mm-ss) ||
|| tore || Object || An internal object which contains the current value of a given image position. This property is set by the system, so this object should not be modified by users. ||
|| id || String || The ElementID of the container. From the [dev_obj_clock Clock Object]'s `id` parameter, mapped over during an `init()` call.  ||
|| contain || HTMLElement || The HTMLElement of the container. From the [dev_obj_clock Clock Object]'s `contain` parameter, mapped over during an `init()` call.  ||
|| model || String || The [dev_obj_clock_model Clock Model]. From the [dev_obj_clock Clock Object]'s `model` parameter, mapped over during an `init()` call.  ||
|| format || String || The [dev_obj_clock_format Clock Format]. From the [dev_obj_clock Clock Object]'s `format` parameter, mapped over during an `init()` call.  ||

|| *Methods* || *Parameters* || *Returns* || *Description* ||
|| load || NONE || void || During a `wind()` call from the [dev_obj_clock Clock Object], the `load()` method is called. This loops through the settings in the `pre` property, and preloads the images the face will use. ||
|| src || `(string prefix, string digit)` || String - Relative Path to an Image || This method takes in an image prefix and a digit, and outputs the relative path to the image. ||
|| createContain || `(string id, string prefix)` || HTMLElement - Div appended to Contain || Creates a DIV element, with an ID equal to `<prefix><container_id>`, and class types: `epiClockElem, epiClock_<prefix>`. This div is then appended as an inline element, with pre-determined margins and padding, to the HTMLElement from the `contain` property. ||
|| createImg || `(string key, string position, string prefix)` || HTMLElement - Img appended to Container || Creates an IMG element, with an ID equal to the provided `key` parameter. The IMG element is then appended to an element with and ID equivalent to the `position` parameter. If no such element exists, the method will call `createContain()` and pass in `position` as `id` and `prefix` as `prefix`. ||
|| render || `(object Output)` || void || When provided with an output array from the [dev_obj_clock Clock Object]'s `render()` method, a properly formatted clock face will be generated/updated. The Output object expects to get an object containing the following key/value pairs: `{y: 'String of the Years', d: 'String of the Days', h: 'String of the Hour', m: 'String of the Minute', s: 'String of the Second', e: 'String of the Meridian'}` ||
|| str || `(string str, string prefix)` || void || Writes the provided string representing some component of the clock into it's appropriate container (which is automatically generated if it doesn't exist). ||
|| img || `(string str, string prefix)` || void || Generates an image representing some component of the clock from the provided `str` parameter, and updates or places it in it's appropriate container (which is automatically generated if it doesn't exist). Uses the `srcing` method to calculate image replacement. ||
|| srcing || `(string bit, string digit, string position)` || void || Calculates the current value of some component of the clock from the provided `bit/digit/position` parameters. The system then compares this value to the last known value rendered. If the value is new and has never been set, a [dev_obj_face_images Dynamic First Image] is rendered. If the value is new and has been set before, a [dev_obj_face_images Dynamic Transition Image] is rendered. If the value is the same, a [dev_obj_face_images Static Image] is rendered. || 

== Source Code ==
{{{
function face(params){
	var me = this;
	params = params || {};
	me.dir = params.dir;
	me.ext = params.ext;
	me.pre = params.pre;
	me.type = params.type || 'str';
	me.sep = params.sep || ':';
	me.tore = {};
	
	me.id;
	me.contain;
	me.model;
	me.format;
	
	me.load = function (){
		var pic = new Image();
		for (bit in me.pre){
			pre = me.pre[bit];
			for (var i = 0; i <= 9; ++i){
				pic.src = me.src(pre,i);
			}
			pic.src = me.src(pre,'am');
			pic.src = me.src(pre,'pm');
			i = 0;
		}
	}
	
	me.src = function (pre, digit){
		return me.dir + '/' + pre + digit + '.' + me.ext;
	}
	
	me.createContain = function (id, prefix){
		var l = 0; var r = 0;
		
		switch (prefix){
			case 'h': l = 5; r = 1; break;
			case 'm': case 's': case 'sep': break;
			default: l = 5; r = 5; break;
		}
	
		var doc = _('span', 
			{id: id, className: 'epiClockElem epiClock_'+prefix, style: {margin: '0 ' + r + 'px 0 ' + l + 'px'}});
		
		me.contain.appendChild(doc);
		return doc;
	}
	
	me.createImg = function (key, pos, prefix){
		var out = $(pos) || me.createContain(pos, prefix);
		var our = _('img', {id: key});

		out.appendChild(our);
		return our;
	}
	
	me.render = function (out){
		for (k in out){
			switch (k){
				case 'd': case 'y': if (me.model == 'C' || out[k] == '00') continue; break;
				case 'e': if (me.model != 'C' || me.format != 'M') out[k] = ''; break;
			}
			
			me.type == 'str' ? me.str(out[k],k) : me.img(out[k],k);
		}
	}
	
	me.str = function(str, prefix){
		pre = prefix + me.id;
		var out = $(pre) || me.createContain(pre, prefix);
		out.innerHTML = '';
		switch (prefix){
			case 'm': case 's': out.innerHTML += me.sep; break;
		}
		out.innerHTML += str;
		switch (prefix){
			case 'd': out.innerHTML += ' days'; break;
			case 'y': out.innerHTML += ' years'; break;
		}
	}
	
	me.img = function(str, prefix){
		pre = prefix + me.id;
		
		switch (prefix){
			case 'e': me.srcing(prefix, str, '0'); break;
			default: for (var i = 0; i < str.length; ++i) me.srcing(prefix, str.charAt(i), i.toString()); break;
		}
		
		switch (prefix.charAt(0)){
			case 'h': case 'm': 
				var skey = 'sep' + me.id + prefix;
				if (!$(skey)){
					var out = me.createContain(skey, 'sep');
					var sep = _('img', {src: me.src('', 'sep')});
					out.appendChild(sep);
				} 
				break;
		}

	}
	
	me.srcing = function (bit, dig, pos){
		pos = pos || '';
		key = bit + me.id + pos;
		var out = $(key) || me.createImg(key, bit + me.id, bit);
		
		if (dig == ''){
			$(bit + me.id).innerHTML = '';
			me.tore[key] = undefined;
		} else if (!ck(me.tore[key])){
			me.tore[key] = dig;
			out.src = me.src(me.pre[2], dig);
		} else if (me.tore[key] == dig){
			out.src = me.src(me.pre[0], dig);
		} else {
			me.tore[key] = dig;
			out.src = me.src(me.pre[1], dig);
		}
	}
}
}}}