#summary Information on the epiClock Clock Object
#labels Phase-Design

= epiClock Clock =
The clock object contains functions and methods to process the internal logic of an individual clock, and calculate the time it should display. 

== Methods and Properties ==

|| *Properties* || *Type* || *Description* ||
|| contain || Dom Element || The page node which contains the epiClock. Referenced by the *id* property. Property filled when the `init()` method is called. ||
|| id || String || Maps to the ID of the element which is to contain the epiClock. ||
|| model || String || Maps to the [dev_obj_clock_model Clock Model]. ||
|| format || String || Maps to the [dev_obj_clock_format Clock Format]. ||
|| face || Object || The clock's [dev_obj_face face object]. ||
|| display || Boolean || A toggle for displaying the clock. If set to true, clock will display normally. If set to false, the clock will run it's normal internal calculations, but it's face will never be rendered. ||
|| displace || Integer || The number of seconds to offset the clock by. This is used to arbitrarily push the clock's time to any given offset. This can be filled by the user, or through the `setDisplace()` method. ||
|| disd || Integer || The Display Offset in Days. To arbitrarily offset the number of days a counter displays. ||
|| days || Integer || The number of days since/remaining on a counter. This property is set automatically by the clocks' `tick()` method, and should not be set by the user, as it will be overwritten during normal operation. ||
|| target || Integer || The target end/beginning date of a counter/timer. This should be in milliseconds since the epoch, and should represent a date. This can be user set, or set through the `setTarget()` method. ||
|| timer || Integer || The length of a timer in seconds. This can be user set, or automatically set by the `setTarget()` method. ||
|| pause || Boolean || An internal pause setting. If true, this clock will act paused, even if the global pause in the [dev_obj_epiClock epiClock Object] is not enabled. *NOTE: Unlike the global pause, a local clock pause will not maintain an offset counter to keep timers in sync. A local clock pause will just silence the clock from calculating the current time!* ||
|| callback || Reference || If the clock is a Timer/Counter, this is the external callback to fire when the timer/counter runs out/down. This default to null. ||
|| time || Array || This contains the current military time, as calculated by the `tick()` method. It is in the format of [hh,mm,ss]. Users may interface with this object to get the raw time for external calculations, however, this will be reset every second. ||
|| meridian || String || If the [dev_obj_clock_format Clock Format] is set to Meridian Time, this will contain either 'am' or 'pm' depending on the time of day. This string is automatically updated by the `tick()` method during a normal cycle. ||

|| *Methods* || *Parameters* || *Returns* || *Description* ||
|| calcDisplace || `(object Settings)` || Integer - Offset in Milliseconds || When provided with an object containing offsets, the method will calculate and return the proper offset. Handles the following settings: *years, days, hours, mins, secs* ||
|| normalize || NONE || void || Calculates the time zone offset and adds the appropriate number of milliseconds to the *displace* property so the base time the clock displays is in UTC. ||
|| setDisplace || `(object Settings)` || void || When provided with an object containing offsets, the method will pipe the settings through the `calcDisplace()` method and set the current offset to the return value of `calcDisplace()`. In addition, it will set the value of the `disd` property to any provided value. Handles the following settings: *disy, disd, years, days, hours, mins, secs* ||
|| timerOffset || `(integer Seconds)` || void || Offsets the *displace* property by the number of provided seconds. This is called by the [dev_obj_epiClock epiClock Object] when it's *cycle* method is called to resume operation after a pause. ||
|| setTarget || `(string DateString|object Settings)` || void || Takes in either a string of a date (ex. "04/18/1986 09:01 PM EST") or a setting object containing a target parameter that contains either a string of a date for a counter target (ex. `{target: "04/18/1986 09:01 PM EST", ...}`) or an object containing offsets for a timer target (ex.`{timer: {hours: 3}, ...}`). This will either set the `target` and/or `timer` and `displace` properties, depending on provided parameters. ||
|| resetTimer || NONE || void || Appends the value of the `timer` property to the `displace` property. ||
|| init || NONE || void || Should be called after the page has loaded, and will be automatically by the [dev_obj_epiClock epiClock Manager] in normal operation. Sets the `contain` property with the HTMLElement object of it's container, and copies over internal parameters to the [dev_obj_face Face Object]. ||
|| wind || NONE || void || Calls the [dev_obj_face Face Object]'s `load()` method. ||
|| fire || NONE || void || If the `callback` parameter is mapped to an actual function, this method will fire that callback. ||
|| tick || NONE || void || Calculates the current time, based on offsets and timers, and puts it's currently calculated time/days into the `time` and `days` properties. ||
|| render || NONE || void || Entry point for the [dev_obj_epiClock epiClock Manager]. If directed to based on internal `pause/display` properties, this function will call the `tick()` method, calculate the current time, transform it based on it's set [dev_obj_clock_format Format] and [dev_obj_clock_model Model] settings, and then feed the calculated settings into it's [dev_obj_face Face]'s `render()` method. ||


== Source Code ==
{{{
function clock(setting) {
	var me = this;
	if (ck(setting,'string')){ setting = {id: setting}; }
	me.contain = null;
	me.id = setting.id;
	me.model = setting.model || 'C';
	me.format = setting.format || 'M';
	me.face = setting.face || new face({type: 'str'});
	me.display = setting.display || true;

 	me.displace = 0;
	me.disd = 0;
	me.days = 0;
	me.target =  0;
	me.timer = 0;
	me.pause = false;
	me.callback = setting.callback || null;
	
	me.time = [0,0,0];
	me.meridian = 'am';
	
	me.calcDisplace = function (setting){
		var years = setting.years || 0;
		var days = setting.days || 0;
		var hours = setting.hours || 0;
		var mins = setting.mins || 0;
		var secs = setting.secs || (me.model.charAt(0) == 'D' ? 1 : 0);
		
		return (years*31570560000+days*86400000+hours*3600000+mins*60000+secs*1000);
	}
	
	me.normalize = function (){
		me.displace += new Date().getTimezoneOffset()*60000;
	}
	
	me.setDisplace = function (setting){
		me.disd = setting.disd || me.disd;
		if (setting.disy) me.disd += Math.floor(365.4 * setting.disy);
		me.displace = (me.model.charAt(0) == 'D' ? -1 : 1) * me.calcDisplace(setting);
	}
	
	me.timerOffset = function (offset){
		switch(me.model){ case 'T': case 'O': break; default: return; }
		me.displace -= offset * 1000;
	}
	
	me.setTarget = function (setting){
		if (ck(setting,'string')) setting = {target: setting};
		if (setting.target){
			me.target = new Date(setting.target).valueOf();
		}
		if (setting.timer){
			me.target = new Date().valueOf();
			me.timer = -1 * (me.calcDisplace(setting.timer) - 1);
			me.displace = me.timer;
		}
	}
	
	me.resetTimer = function(){
		me.displace += me.timer;
	}
	
	me.setDisplace(setting);

	me.setTarget(setting);
	
	me.init = function (){
		me.contain = $(me.id);
		me.face.id = me.id;
		me.face.contain = me.contain;
		me.face.model = me.model;
		me.face.format = me.format;
	};
	
	me.wind = function (){
		me.face.load();
	}
	
	me.fire = function (){
		if (ck(me.callback, 'function')) me.callback();
		me.callback = null;
	}
	
	me.tick = function (){
		var now = new Date(new Date().valueOf() + me.displace);
		var offset;
		
		switch (me.model){
			case 'C':
				me.time = [now.getHours(), now.getMinutes(), now.getSeconds()]; 
				return;
			case 'S':
				me.displace += 1000;
				offset = me.displace;
				break;
			case 'U':
				offset = new Date(now.valueOf() - me.target);
				break;
			case 'D':
			case 'DU':
			case 'T':
			case 'O':
				offset = new Date(me.target - now.valueOf());
				break;
		}
		
		var sec = Math.floor(offset.valueOf()/1000);
		me.days = me.disd+calc(sec,86400,100000);
		me.time = [calc(sec,3600,24),calc(sec,60,60),calc(sec,1,60)];
	}
		
	me.render = function (){
		if (me.pause) return;
		me.tick();
		
		if (me.days == -1){
			switch (me.model){
				case 'D':
				case 'O':
					me.fire();
					epiClock.kill(me.id);
					me.contain.innerHTML = 'This Timer Has Expired'; return;	
					break;
					
				case 'DU':
					me.fire();
					me.model = 'U'; me.render(); return;
					break;
					
				case 'T':
					me.fire();
					me.resetTimer();
					me.render();
					break;
			}
		}
		
		if (me.model == 'C'){
			me.meridian = 'am';
		
			if (me.time[0] >= 12){
				if (me.format == 'M') 
					me.time[0] -= (me.time[0] == 12 ? 0 : 12);
				me.meridian = 'pm';
			} else if (me.time[0] == 0)
				me.time[0] += 12;
		}

		var output = {
			y: tock(Math.floor(me.days/365.4)),
			d: tock(me.days > 365 ? me.days%365 : me.days),
			h: tock(me.time[0]), 
			m: tock(me.time[1]), 
			s: tock(me.time[2]),  
			e: me.meridian
		};
		
		if (me.display) me.face.render(output);
	}
	
	if (setting.utc) me.normalize();
}
}}}